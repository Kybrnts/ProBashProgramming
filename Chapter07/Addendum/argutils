#: Title       : Nmeutils
#: Date        : 2016-03-06
#: Author      : "Kybernetes" <correodelkybernetes@gmail.com>
#: Version     : 1.0.0
#: Description : Dash function declarations file
#:             : Adds usefull shell tools for names (references)
#: Options     : N/A

##
## Global variables declarations ---------------------------------------------------------------------------------------
if [ ! "$_DEF_MSNGARGERRS" ]; then ## Missng args error messages // Do not include if already included
    ## Already included test flag
    readonly _DEF_MSNGARGERRS=:
    ##
    ## Reserve a symbol for null constant. Useful when stopping exec. w/"Display  Error if Null or Unset" param. exp
    readonly _NULL
    ##
    ## Constants for default error messages (Respect previously defined values, but now make them constant -------------
    ## Error messages for missing..
    readonly _MSNG_ARG_ERR_MSG_DFLT=${_MSNG_ARG_ERR_MSG_DFLT:-"Missing argument"}         ## An argument;
    readonly _MSNG_NMA_ERR_MSG_DFLT=${_MSNG_NMA_ERR_MSG_DFLT:-"Missing name argument"}    ## A name argument;
    readonly _MSNG_NNA_ERR_MSG_DFLT=${_MSNG_NNA_ERR_MSG_DFLT:-"Missing nonnull argument"} ## A Nonnull argument;
    readonly _MSNG_INA_ERR_MSG_DFLT=${_MSNG_INA_ERR_MSG_DFLT:-"Missing integer argument"} ## An Integer argument;
    readonly _MSNG_IDA_ERR_MSG_DFLT=${_MSNG_IDA_ERR_MSG_DFLT:-"Missing index argument"}   ## An Index argument;
    readonly _MSNG_CLR_ERR_MSG_DFLT=${_MSNG_CLR_ERR_MSG_DFLT:-"Missing caller argument"}  ## A caller function name.
    ##
    ## Runtime configuration values ------------------------------------------------------------------------------------
    ## This are the ones meant to be used by the functions. Values may be updated during execution
    _MSNG_ARG_ERR_MSG=$_MSNG_ARG_ERR_MSG_DFLT ## Missing argument error message
    _MSNG_NMA_ERR_MSG=$_MSNG_NMA_ERR_MSG_DFLT ## Missing name arg
    _MSNG_NNA_ERR_MSG=$_MSNG_NNA_ERR_MSG_DFLT ## Missing nonull arg
    _MSNG_INA_ERR_MSG=$_MSNG_INA_ERR_MSG_DFLT ## Missing integer arg
    _MSNG_CLR_ERR_MSG=$_MSNG_CLR_ERR_MSG_DFLT ## Missing caller functio name
fi
if [ ! "$_DEF_BADARGERRS" ]; then ## Bad args error messages // Do not include if already included
    ## Already included test flag
    readonly _DEF_BADARGERRS=:
    ##
    ## Constants for default error messages (Respect previously defined values, but now make them constant -------------
    ## Error messages for bad..
    readonly _BAD_ARG_ERR_MSG_DFLT=${_BAD_ARG_ERR_MSG_DFLT:-"Bad argument"}            ## Argument (generic);
    readonly _BAD_NMA_ERR_MSG_DFLT=${_BAD_NMA_ERR_MSG_DFLT:-"Bad name argument"}       ## Invalid name argument;
    readonly _BAD_CNA_ERR_MSG_DFLT=${_BAD_CNA_ERR_MSG_DFLT:-"Bad conv. name argument"} ## Inval. name as per convention;
    readonly _BAD_NNA_ERR_MSG_DFLT=${_BAD_NNA_ERR_MSG_DFLT:-"Bad null argument"}       ## A null argument;
    readonly _BAD_INA_ERR_MSG_DFLT=${_BAD_INA_ERR_MSG_DFLT:-"Bad integer argument"}    ## A bad integer argument;
    readonly _BAD_IDA_ERR_MSG_DFLT=${_BAD_IDA_ERR_MSG_DFLT:-"Bad index argument"}      ## A bad Index argument.
    ##
    ## Error message for too many arguments ----------------------------------------------------------------------------
    readonly _EXTR_ARG_ERR_MSG_DFLT=${_EXTR_ARG_ERR_MSG_DFLT:-"Too many arguments"}
    ##
    ## Runtime configuration values ------------------------------------------------------------------------------------
    ## This are the ones meant to be used by the functions. Values may be updated during execution
    _BAD_ARG_ERR_MSG=$_BAD_ARG_ERR_MSG_DFLT
    _BAD_CNA_ERR_MSG=$_BAD_CNA_ERR_MSG_DFLT
    _BAD_NMA_ERR_MSG=$_BAD_NMA_ERR_MSG_DFLT
    _BAD_NNA_ERR_MSG=$_BAD_NNA_ERR_MSG_DFLT
    _BAD_INA_ERR_MSG=$_BAD_INA_ERR_MSG_DFLT
    _BAD_IDA_ERR_MSG=$_BAD_IDA_ERR_MSG_DFLT
    _EXTR_ARG_ERR_MSG=$_EXTR_ARG_ERR_MSG_DFLT ## Extra argument provided
fi
##
## Declarations
if [ ! "$_DEF_ARGUTILS" ]; then
    ## Already included test flag
    readonly _DEF_NMEUTILS=:
    ##
    ## Function declarations
    valnme() { #@ DESCRIPTION: Tests if $1 string is a valid variable shell name.
               #@ USAGE: valnme '[ STRING ]'
        ## Function header
        set -- ${1+"$1"}
        
        : ${1?"valnme: $_MSNG_ARG_ERR_MSG"} ## Require a set string (i.e. not the NULL pointer)
        case $1 in                       ## Fail if:
            "") return 1 ;;              ## * Is the null string;
            [^a-zA-Z_]*) return 2 ;;     ## * Begins w/any other than letter or underscore;
            *[^a-zA-Z0-9_]*) return 3 ;; ## * Contains any other than letter, number or underscore.
        esac
    }
    cnvnme() { #@ DESCRIPTION: Tests if $1 string is a valid name as per defined naming convention to avoid colisions
               #@              between local and gloval names passed as positionsl parameters. All valid names as per
               #@              this criterion MUST be valid variable shell names as well.
               #@ USAGE: cnvname '[ STRING ]'
        ## Function header
        set -- ${1+"$1"}

        : ${1?"valnme: $_MSNG_ARG_ERR_MSG"} ## Require a set string (i.e. not the NULL pointer)        
        case $1 in                       ## Fail if:
            "") return 1 ;;              ## * Is the null string;
            [^_]*) return 2 ;;           ## * Do NOT start with a leading underscore, as per defined convention;
            *[^a-zA-Z0-9_]*) return 3 ;; ## * Contains any other than letter, number or underscore.
        esac
    }
    
    _isunset() { #@ DESCRIPTION: Primitive. Tests if NAME present in $2 is NOT set (i.e. expands to null pointer). The
                 #@              Name required for $1 is the name of the derived function that calls it. Exit status
                 #@              will be zero on success and greater than zero when test fails.
                 #@ USAGE: _isunset "caller" NAME
                 #@        DON'T CALL DIRECTLY unless sure of what you're doing. Call through below wrappers instead.
        ## Function header
        set -- ${1+"$1"} ${2+"$2"}

        : ${1:?"_isunset: $_MSNG_CLR_ERR_MSG"}        ## Caller function's name (must be quoted)
        : ${2?"$clr: $_MSNG_NMA_ERR_MSG"}             ## Name to test (require a set string)
        valnme "$2" || ${2?"$clr: $_BAD_NMA_ERR_MSG"} ## Require valid name for test
        ## Check if referenced value is unset
        ## Expanded to "x" only if name is unset, in that case expansion will became a NOT null string
        eval "[ -z \${$2+x} ]"
    }
    isunset() { #@ DESCRIPTION: Derived/Wrapper. Tests if NAME present in $1 is NOT set by using _isunset(). 
                #@ USAGE: isunset NAME
        set -- "isunset" ${1+"$1"} ## Set quoted parameters only if they are present
        _isunset "$@"
    }
    isset() { #@ DESCRIPTION: Derived/Wrapper. Tests if NAME present in $1 IS set by using _isunset().
              #@ USAGE: isset NAME
        set -- "isunset" ${1+"$1"} ## Set quoted parameters only if they are present        
        ! _isunset "$@"            ## Fail when _isunset() succeeds and vice-versa
    }
    setvar() { #@ DESCRIPTION: Sets one or more variables to specified value by reference. At lest one name and value is
               #@              required, using the -v switch. Additional assignments may be specified. Any given name is
               #@              checked to be a valid shell name before the assignment takes place except when using -u,
               #@              where check is avoided for that specific variable. Values may be null, but not unset.
               #@ USAGE: setvar -[v|u] NAME '[ VALUE ]' [ -[v|u] NAME '[ VALUE ]' .. ]
        ## Local variables
        local estr=  ## Eval string to execute        
        : ${1?"setvar: $_MSNG_ARG_ERR_MSG"} ## Require at least one argument

        while [ $# -ne 0 ]; do ## While we still have arguments, process them in groups of 3
            case $1 in
                -u) ## First of the group must be the -u or -v switch, in this case -u (set unsafe mode)
                    : ${2?"setvar: $_MSNG_NMA_ERR_MSG"}  ## Reuqire the following arg to be set as well (name)
                    : ${3?"setvar: $_MSNG_NMA_ERR_MSG"}  ## And the next one also (3ue)
                    shift 3                              ## Clear all stored args
                    estr=${estr:+"$estr "}"$2=\"$3\"" ;; ## Append assignment to eval string without valname()
                -v) ## First of the group must be the -v or -v switch, in this case -v (set safe mode)
                    : ${2?"setvar: $_MSNG_NMA_ERR_MSG"}  ## Reuqire the following arg to be set as well (name)
                    : ${3?"setvar: $_MSNG_NMA_ERR_MSG"}  ## And the next one also (value)
                    shift 3                              ## Clear all stored args
                    valnme "$2" || ${2?"setvar: $_BAD_NMA_ERR_MSG"} ## Require a valid name on name arg
                    estr=${estr:+"$estr "}"$2=\"$3\"" ;;            ## Append assig2nt to e3 string
                *)  ## Fail in any other case
                    shift $#                             ## No more args needed
                    : ${1?"setvar: $_BAD_ARG_ERR_MSG"} ;;
            esac
        done
        eval "$estr" ## Evaluate and execute eval string after looping through args
    }
    __getvar() { #@ DESCRIPTION: Primitive. Stores $3 name's value $2 name. $1 Stores the calling function's name.
                 #@ USAGE: __getvar CALLING_FUNCTION BE_UNSAFE NAME_WRITE NAME_READ
                 #@        DO NOT CALL DIRECTLY, call through below derived wrappers instead
        ## Function header
        set --  ${1+"$1"} ${2+"$2"} ${3+"$3"} ${4+"$4"}

        : ${1:?"__getvar: $_MSNG_CLR_ERR_MSG"} ## Require the calling function's name
        : ${2:?"$1: $_MSNG_ARG_ERR_MSG"}     ## Be unsafe flag. enables parameters sanity check
        : ${3?"$1: $_MSNG_NMA_ERR_MSG"}      ## Require a name to write to
        : ${4?"$1: $_MSNG_NMA_ERR_MSG"}      ## Require a neme to rewad from
        case $2 in
            0) 
                cnvnme "$3" || ${2?"$1: $_BAD_CNA_ERR_MSG"}    ## Validate name to write or fail
                valnme "$4" || ${3?"$1: $_BAD_NMA_ERR_MSG"} ;; ## Validate name to read from
        esac
        eval "isset \$4" || return 1                  ## If var is unset fail gracefully
        eval "setvar -u $3 \"\$$4\""             ## Set value of to-read name into to-write one (unsafe mode)
    }
    _getvar() { #@ DESCRIPTION: Derived wrapper to __getvar(). Stores $2 name's value to $1 name.
                #@ USAGE: _getvar NAMEW NAMER        
        set --  ${1+"$1"} ${2+"$2"} ## Set quoted parameters only if they are present
        __getvar "_getvar" 0 "$@"
    }
    _getvar_u() { #@ DESCRIPTION: Derived wrapper to __getvar(). Stores $2 name's value to $1 name.
                  #@ USAGE: _getvar NAMEW NAMER
        set --  ${1+"$1"} ${2+"$2"} ## Set quoted parameters only if they are present
        __getvar "_getvar" 1 "$@"
    }
    getvar() { #@ DESCRIPTION: Derived wrapper to __getvar(). Prints $1 name's value to STDOUT
               #@ USAGE: getvar NAME
        set -- ${1+"$1"}
        local ___gtvr=
        __getvar "getvar" 0 ___gtvr "$@"
        [ "$___gtvr" ] && printf "%s\n" "$___gtvr"
    }
    getvar_u() { #@ DESCRIPTION: Derived wrapper to __getvar(). Prints $1 name's value to STDOUT
               #@ USAGE: getvar NAME
        set -- ${1+"$1"}
        local ___gtvr=
        __getvar "getvar" 1 ___gtvr "$@"
        [ "$___gtvr" ] && printf "%s\n" "$___gtvr"
    }
fi
