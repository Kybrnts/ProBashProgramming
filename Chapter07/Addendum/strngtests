#: Title       : Strngtests
#: Date        : 2016-03-06
#: Author      : "Kybernetes" <correodelkybernetes@gmail.com>
#: Version     : 1.0.0
#: Description : Dash function declarations file
#:             : Adds usefull string-test functions
#: Options     : N/A

##
## Includes and needed externals
. /usr/local/lib/msngargerrs || exit 1 ## Missing argument error message strings
. /usr/local/lib/badargerrs || exit 1  ## Bad argument error message strings
##
## Declarations
if [ ! "$_DEF_STRNGTESTS" ]; then ## Do not include if already included
    ## Already included test flag
    readonly _DEF_STRNGTESTS=:
    ##
    ## Function declarations
    _issubstr() { #@ DESCRIPTION:
                  #@ USAGE:
        ## Local variables (If local is used, it should appear as the first statement of a function)
        local clr sub str
        clr=${1:?"_issubstr: $_MSNG_CLR_ERR_MSG"} shift 1 ## Require the calling function's name
        ## Function Header
        sub=${1?"$clr: $_MSNG_ARG_ERR_MSG"}
        str=${2?"$clr: $_MSNG_ARG_ERR_MSG"}
        shift $# ## Header ends removing any aditional pos. pars.
        case $str in              ## Does string match substring w/additional left or right chars?
            *"$sub"*) return 0 ;; ## Yes, then it is a substring
        esac                      ##
        return 1                  ## No, hence it is not a substring
    }    
    issubstr() { #@ DESCRIPTION: Tests if $1 string is contained in string $2
                 #@ USAGE: issubstr '[ STRING1 ]' '[ STRING2 ]'
        ## Function Header
        set -- ${1+"$1"} ${2+"$2"}
        _issubstr "issubstr" "$@"
    }
    issupstr() { #@ DESCRIPTION: Tests if $1 string contains string $2
                 #@ USAGE: issupstr '[ STRING1 ]' '[ STRING2 ]'
        ## Function Header
        set -- ${2+"$2"} ${1+"$1"} ## Invert arguments order
        _issubstr "issubstr" "$@"  ## Now check if $2 is substring of $1
    }
    nullstr() { #@ DESCRIPTION: Tests if $1 string contains any characters (other than '\0')
                #@ USAGE: null '[ TEST_STRING ]'
        ## Function Header
        set -- ${1+"$1"}
        issubstr "$@" "" ## Is $1 substring of the null?
    }

    numonly() { #@ DESCRIPTION: Tests if $1 string contains only numeric characters
                #@ USAGE: numonly '[ TEST_STRING ]'
        ## Local variables (If local is used, it should appear as the first statement of a function)
        local str
        ## Function header
        str=${1?"numonly: $_MSNG_ARG_ERR_MSG"}
        shift $# ## Header ends removing any aditional pos. pars.
        case $str in              ## Test if the string is null or contains nondigit chars
            "") return 1 ;;       ## Not even a character (other than '\0')
            *[!0-9]*) return 2 ;; ## Contains non numeric chars
        esac
    }
    alponly() { #@ DESCRIPTION: Tests if $1 string contains only alphabetic characters
                #@ USAGE alponly '[ STRING ]'
        ## Local variables (If local is used, it should appear as the first statement of a function)
        local str
        ## Function header
        str=${1?"alponly: $_MSNG_ARG_ERR_MSG"}
        shift $# ## Header ends removing any aditional pos. pars.
        ## Test fails if string is null or contain nona alphabetic chars
        case $str in
            "") return 1 ;;          ## Not even a single character
            *[!A-Za-z]*) return 2 ;; ## Non alphabetic chars found
        esac    
    }
    alnmonly() { #@ DESCRIPTION: Tests if $1 string is alphanumeric
                 #@ USAGE: alnumonly '[ TEST_STRING ]'
        ## Local variables (If local is used, it should appear as the first statement of a function)
        local str
        ## Function header
        str=${1?:"alnmonly: $_MSNG_ARG_ERR_MSG"}
        shift $# ## Header ends removing any aditional pos. pars.
        case $str in ## Test for non alphabetic characters
            "") return 1 ;;
            *[!A-Za-z0-9]*) return 2 ;;
        esac
    }
    
    valint() { #@ DESCRIPTION: Tests if $1 string is a valid integer string. This is useful to check vars before
               #@              feeding them to arithmetic expansion. Remember that in BASH's arithmetic evaluation:
               #@              * Constants with a leading 0 are interpreted as octal numbers;
               #@              * A leading 0x or 0X denotes hexadecimal;
               #@              * Otherwise, numbers take the form [base#]n, where base is a decimal number between 2
               #@                and 64 representing the arithmetic base, and n is a number in that base.
               #@              However the later notation doesn't seem to be supported by Dash
               #@ USAGE: valint '[ TEST_STRING ]'
        ## Function header
        ## Local variables (If local is used, it should appear as the first statement of a function)
        local str
        ## Function header
        str=${1?"valint: $_MSNG_ARG_ERR_MSG"}
        shift $# ## Header ends removing any aditional pos. pars.
        str=${str#"${str%%[!\-+]*}"} ## Rm from string's back up to the first +/-, then rm its complement from front.
        case $str in                            ## Now check on unsigned string:
            "") return 1 ;;                     ## Fail if empty (empty strings are not supported by arithm. eval)
            0[xX]*)                             ## If hexadecimal notation is used
                case ${str#??} in               ## Remove leading Ox or 0X
                    *[!0-9A-Fa-f]*) return 2 ;; ## Fail if non-hexadecimal digit chars are present
                esac ;;
            0*)                                 ## If octal notation is used
                case ${str#?} in                ## Remove leading 0
                    *[!0-7]*) return 3 ;;       ## Fail if non-hexadecimal digit chars are present
                esac ;;
            *) numonly "$str" || return 4 ;;    ## In any other case fail if non numeric chars are present
        esac
    }
    valindx() { #@ DESCRIPTION: Tests if $1 contains a valid nonnegative decimal integer (i.e. an index)
                #@ USAGE: valindx '[ TEST_STRING ]'
        ## Local variables (If local is used, it should appear as the first statement of a function)
        local str
        ## Function header
        str=${1?"valindx: $_MSNG_NNA_ERR_MSG"}
        shift $# ## Header ends removing any aditional pos. pars.
        case $str in              ## Fail when:
            "") return 1 ;;       ## * Null string;
            *[!0-9]*) return 2 ;; ## * Contains non numeric chars;
            0*) return 3 ;;       ## * Starts w/zero (e.g. octal notation is invalid).
        esac
    }
    valflt() { #@ DESCRIPTION: Tests if $1 contains a valid floating point number (also spporting sci notation)
               #@ USAGE: valflt '[ TEST_STRING ]'
        ## Local variables (If local is used, it should appear as the first statement of a function)
        local str
        ## Function header
        str=${1?"valfloat: $_MSNG_ARG_ERR_MSG"}                ## String to be tested
        shift $# ## Header ends removing any aditional pos. pars.
        str=${str#[\-+]}                                       ## Remove single leading sign (if any)
        case $str in                                           ## Process the string from right to left
            *[0-9])                                            ## Now string must end in numeric chars (digits)
                str=${str%"${str##*[!0-9]}"}                   ## Remove all trailing digits
                case $str in                                   ## Now if string..
                    "") return 0 ;;                            ## Is empty? Yes so whole number (numonly), so valid;
                    *[0-9].) numonly "${str%?}" || return 3 ;; ## Normal float, check numonly before single dot;
                    *[0-9][Ee] | *[0-9][Ee][\-+])              ## Sci float so..
                        case ${str%[Ee]*} in                   ## Remove notation's exponent part before check
                            *[!.0-9]*) return 4 ;;             ## Fail if contains non-numerics or dots;
                            *.*.*) return 5 ;;                 ## Also if contains more than one dot;
                            *[!0-9]) return 6 ;;               ## Also if it finishes w/a non-numeric
                        esac ;;
                    *) return 2 ;;                             ## Not a whole, normal flt or sci, so invalid;
                esac ;;
            *) return 1 ;;                                     ## It does not ends with numerics, hence invalid
        esac
    }
    
    leapyr() { #@ DESCRIPTION: Checks if the year string number in $1 is a leap year.
               #@ USAGE: leapyr '[ YYYY ]'
        ## Local variables (If local is used, it should appear as the first statement of a function)
        local ystr
        ## Function header
        ystr=${1:?"leapyr: $_MSNG_ARG_ERR_MSG"}
        shift $# ## Header ends removing any aditional pos. pars.
        ystr=${ystr#"${ystr%%[!0]*}"}  ## Remove leading zeros (if any) 
        numonly "$ystr" || return 1    ## Must be a digits only // Not even a valid year
        if [ $((ystr%4)) -ne 0 ]; then     ## Not a multiple of 4?
            return 2                       ## Not leap
        elif [ $((ystr%100)) -ne 0 ]; then ## Neither a multiple of 4 nor of 100?
            return 0                       ## Leap
        elif [ $((ystr%400)) -ne 0 ]; then ## Neither a multiple of 4 nor of 100 nor of 400?
            return 2                       ## Not leap
        fi                                 ## Leap in any other case
    }
    valdte() { #@ DESCRIPTION: Checks if the string value of $1 is a valid date string of the format yyyymmdd
               #@ USAGE: valdate '[ YYYYYmmdd ]'
        ## Local variables (If local is used, it should appear as the first statement of a function)
        local dtestr mm mdd
        ## Function header
        dtestr=${1:?"valdate: $_MSNG_ARG_ERR_MSG"} ## String to test
        shift $# ## Header ends removing any aditional pos. pars.
        mm=0 dd=0 mdd=0                     ## Month, days and max mont's days container respectively
        dtestr=${dtestr#"${dtestr%%[!0]*}"} ## Remove leading zeros from date string
        [ ${#dtestr} -gt 4 ] || return 1    ## 00010101 is the minimum, 5 digits needed after trimming leading zeros
        numonly "$dtestr" || return 1       ## Allow digits only date
        dd=${dtestr#"${dtestr%??}"}         ## Extract day substring from date
        dtestr=${dtestr%"$dd"}              ## Remove day substring from date
        dd=${dd#0}                          ## Remove the leading zero from day if any
        mm=${dtestr#"${dtestr%??}"}         ## Extract month substr from date
        dtestr=${dtestr%"$mm"}              ## Remove month substr from date, now dtestr contains year
        mm=${mm#0}                          ## Remove leathing zero from month

        [ 0 -le $mm -a $mm -le 13 ] || return 2      ## Validate month
        case $mm in                                  ## Validate day number in relationship to month and year: 
            1|3|5|7|8|10|12) mdd=31 ;;               ## For months 1, 3, 5,.., set a maximum day number of 31;
            4|6|9|11) mdd=30 ;;                      ## For months 4, 6, 9.., set a maximum day of 30;
            *) leapyr $dtestr && mdd=29 || mdd=28 ;; ## For 2nd month, check for leap year
        esac
        [ 0 -le $dd -a $dd -le $mdd ] || return 2
    }
    valtme() { #@ DESCRIPTION: Checks if the string value of $1 is a valid time strin gof the format HHMMSS
               #@ USAGE: valtme '[ HHMMSS ]'
        ## Local variables (If local is used, it should appear as the first statement of a function)
        local tmestr i sub
        ## Function header
        tmestr=${1:?"valtime: $_MSNG_ARG_ERR_MSG"} ## Time string to test
        shift $# ## Header ends removing any aditional pos. pars.
        i=:: sub=                                     ## A counter and a substring container
        numonly "${tmestr#[\-+]}" || return 1         ## Check for numeric only w/out leading sign (ngtv time supported)
        ## Process time string from right to left in groups of two characters
        while [ "$i" ]; do                            ## Repeat for seconds substring and for minutes substring
            sub=${tmestr#"${tmestr%??}"}              ## Extract last two digits substring
            tmestr=${tmestr%"$sub"}                   ## Remove last two digits from time string
            sub=${sub#[\-+0]}                         ## Remove leading zero and or +/- if any, from substring
            [ 0 -le $sub -a $sub -le 60 ] || return 2 ## Check if substring is within range
            [ "$tmestr" ] || return 0                 ## If there are no more digits, succeed
            i=${i%?}                                  ## Decrease counter
        done
        sub=${tmestr#"${tmestr%??}"}                  ## Repeat above proces one las time for hours substring
        tmestr=${tmestr%"$sub"}
        sub=${sub#\-+0}
        [ 0 -le $sub -a $sub -lt 24 ] || return 2
    }
fi
