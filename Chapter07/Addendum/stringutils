#: Title       : Utils
#: Date        : 2016-06-21
#: Author      : "Kybernetes" <correodelkybernetes@gmail.com>
#: Version     : 1.0
#: Description : Bash function declarations file
#:             : Adds usefull string manipulation functions
#: Options     : N/A

## Global variables
                                                              ## $_MISS_ARG_ERR_MSG error messages:
declare -r _MISS_ARG_ERR_MSG="Missing argument"               ## Arg
declare -r _MISS_NMA_ERR_MSG="Missing name argument"          ## Name arg
declare -r _MISS_NEA_ERR_MSG="Missing nonempty argument"      ## Nonempty arg
declare -r _MISS_VIA_ERR_MSG="Missing valid integer argument" ## Integer arg
                                 ## Default optional values
declare -ri _INSRT_STR_DFLT=2    ## Default insert string location
declare -ri _OVRLY_STRT_DFLT=1   ## Default overlay string location
declare -ri _TRM_STR_DFLT=$' \t' ## Defalut string to be trimmed

## Function declarations
__val2decint() { #@ DESCRIPTION: Primitive function. Turns valid decimal integer string $2 into decimal arithmetic
                 #@              evaluable by removing its leading zeros (sign skipped), and writes result in $1. 
                 #@              Otherwise it will be treated as octal inside an arithmetic evaluation.
                 #@ USAGE: __val2decint NAME '[ INT_STRING ]' (usable only inside intended wrappers)
    local ref_intstr=${1:?"${FUNCNAME[1]}: $_MISS_NMA_ERR_MSG"} ## ${FUNCNAME[1]} Expands to callling name
    local intstr=${2:?"${FUNCNAME[1]}: $_MISS_VIA_ERR_MSG"}     ##
    shift $#
    ## NOTE: This "Primitive" is meant to be ONLY INDIRECTLY called by a few "derived" wrappers, which assume their
    ##       header will be handled by this primitive. This method provides heder reuse. Also Notice the reference to
    ##       calling function in above sustitutions.
    ##
    ## We don't want leading +,- or zeros, so keep them separately to later remove them
    ## To store the above, remove from back any different characters
    local unwntd=${intstr%%[^+\-0]*}
    ## Then keep hyphen character if present (for negatives), and then remove the unwanted from the beginning
    printf -v $ref_intstr "%s" ${intstr%%[^-]*}${intstr#$unwntd}
}
_val2decint() { #@ DESCRIPTION: Derived. valid decimal integer string $2 into decimal arithmetic evaluable using
                #@              __val2decint, and writes result in $1. (Wrapper)
                #@ USAGE: _val2decint [ __val2decint args ]
    set -- "${@:1:2}" ## Keep only the first two positional pars. and rewrite "$@"
    __val2decint "$@"
}
val2decint() { #@ DESCRIPTION: Derived. Turns valid decimal integer string $2 into decimal arithmetic evaluable using
               #@              __val2decint, and writes result in STDOUT. (Wrapper)
               #@ USAGE: val2decint [ __val2decint args ]
    set -- "${@:1:1}" ## Keep only first positional par., and rewrite "$@"
    local ___vl2dcnt= ## Variable to be written by __val2decint
    __val2decint ___vl2dcnt "$@"
    printf "%d\n" $___vl2dcnt
}

__repeat() { #@ DESCRIPTION: Primitive. Repeat $2 string N times and write it to name $1
             #@ USAGE: __repeat NAME '[ STRING ]' [ NUMBER ]
    ## Function header
    local ref_rep=${1:?"${FUNCNAME[1]}: $_MISS_NMA_ERR_MSG"}
    local repstr=${2?"${FUNCNAME[1]}: $_MISS_ARG_ERR_MSG"}
    local -i num=${3:-1}
    shift $#

    while (( ${#repstr} < $num && ${#repstr} > 0 )); do ## Loop until string exceeds desired length
	repstr+=$repstr$repstr                          ## 3 seems to be the optimum number
    done
    printf -v $ref_rep "%s" "${repstr:0:$num}"          ## Trim to desired length & write result
}
_repeat() { #@ DESCRIPTION: Derived
            #@ USAGE:
    set -- "${@:1:3}"
    __repeat "$@"
}
repeat() { #@ DESCRIPTION: Derived. Repeat a repstr N times
           #@ USAGE: repeat [ __repeat args ]
    set -- "${@:1:2}"                                   ## Keep only the first two arguments
    local ___rpt=                                       ## Variable to be written by _repeat
    _repeat ___rpt "$@"
    [ -n "$___rpt" ] && printf "%s\n" "$___rpt"
}

stdalert() { #@ DESCRIPTION: Prints in-box-alert-message
             #@ USAGE: alert '[ MESSAGE ]' [ BORDER ]
    local message=${1?"$FUNCNAME: $_MISS_ARG_ERR_MSG"}
    local border=${2:-#}
    shift $#
    
    local ___rpt=
    _repeat ___rpt "$border" $(( ${#message} + 6 ))
    printf '\a%s\n' "$___rpt" ## \a = BEL
    printf '%2.2s %s %2.2s\n' "$___rpt" "$message" "$___rpt"
    printf '%s\n' "$___rpt"
}

__revstr() { #@ DESCRIPTION: Functio core. Reverse $1 string order and store results
             #@ USAGE: revstr NAME [ STRING ]
    local ref_str=${1:?"${FUNCNAME[1]}: $_MISS_NMA_ERR_MSG"}
    local string=$2
    shift $#

    local temp= revstr=                 ## Now revstr is a local variable

    while [ -n "$string" ]; do          ## While string's size is not zero..
	temp=${string#?}                ## Get everything but first char on temp
	revstr=${string%"$temp"}$revstr ## Then get first char only, and place it at the beginning of global
	string=$temp                    ## Replace string with temp (remove its first char)
    done
    printf -v $ref_str "%s" "$revstr"   ## Print reversed string to referenced variable
}
_revstr() { #@ DESCRIPTION: 
            #@ USAGE:
    set -- "${@:1:2}"    
    __revstr "$@"
}
revstr() { #@ DESCRIPTION: Print reverse version of the string $1
           #@ USAGE: revstr [ STRING ]
    set -- "${@:1:1}"
    local ___rvstr=            ## Storage for refstr output
    _revstr ___rvstr "$@"      ## Revert string into above storage
    printf "%s\n" "$___rvstr"  ## Print it to STDOUT
}

__lower() { #@ DESCRIPTION:
            #@ USAGE:
    local ref_c=${1:?"$FUNCNAME: $_MISS_NMA_ERR_MSG"}
    local str=${2?"$FUNCNAME: $_MISS_ARG_ERR_MSG"}
    shift $#

    local lwr=
    case $str in
	A*) lwr=a ;; B*) lwr=b ;; C*) lwr=c ;; D*) lwr=d ;;
	E*) lwr=e ;; F*) lwr=f ;; G*) lwr=g ;; H*) lwr=h ;;
	I*) lwr=i ;; J*) lwr=j ;; K*) lwr=k ;; L*) lwr=l ;;
	M*) lwr=m ;; N*) lwr=n ;; Ñ*) lwr=ñ ;; O*) lwr=o ;;
	P*) lwr=p ;; Q*) lwr=q ;; R*) lwr=r ;; S*) lwr=s ;;
	T*) lwr=t ;; U*) lwr=u ;; V*) lwr=v ;; W*) lwr=w ;;
	X*) lwr=x ;; Y*) lwr=y ;; Z*) lwr=z ;; Á*) lwr=á ;;
	É*) lwr=é ;; Í*) lwr=í ;; Ó*) lwr=ó ;; Ú*) lwr=ú ;;
	*) lwr=${str%"${str#?}"} ;;
    esac
    printf -v $ref_c "%s" "$lwr"
}
_lower() { #@ DESCRIPTION: 
           #@ USAGE:
    set -- "${@:1:2}"
    __lower "$@"
}
lower() { #@ DESCRIPTION: 
          #@ USAGE:
    set -- "${@:1:1}"
    local ___lwr=
    __lower ___lwr "$@"
    [ -n  "$___lwr" ] && printf "%s\n" "$___lwr"
}

__to_lower() { #@ DESCRIPTION:
               #@ USAGE:
    local ref_wrd=${1:?"${FUNCNAME[1]}: $_MISS_NMA_ERR_MSG"}
    local word=${2?"${FUNCNAME[1]}: $_MISS_ARG_ERR_MSG"}
    shift $#

    local __lower=
    _lower __lower "$word"
    printf -v $ref_word "%s%s" "$__lower" "${word#?}"
}
_to_lower() { #@ DESCRIPTION:
              #@ USAGE:
    set -- "${@:1:2}"
    __to_lower "$@"
}
to_lower() { #@ DESCRIPTION:
             #@ USAGE:
    set -- "${@:1:1}"
    local ___t_lower=
    __to_lower ___t_lower "$@"
    [ -n "$___t_lower" ] && printf "%s\n" "$___t_lower"
}

__upper() { #@ DESCRIPTION: 
            #@ USAGE:
    local ref_c=${1:?"${FUNCNAME[1]}: $_MISS_NMA_ERR_MSG"}
    local str=${2?"${FUNCNAME[1]}: $_MISS_ARG_ERR_MSG"}
    shift $#

    local upr=
    case $str in
	a*) upr=A ;; b*) upr=B ;; c*) upr=C ;; d*) upr=D ;;
	e*) upr=E ;; f*) upr=F ;; g*) upr=G ;; h*) upr=H ;;
	i*) upr=I ;; j*) upr=J ;; k*) upr=K ;; l*) upr=L ;;
	m*) upr=M ;; n*) upr=N ;; ñ*) upr=Ñ ;; o*) upr=O ;;
	p*) upr=P ;; q*) upr=Q ;; r*) upr=R ;; s*) upr=S ;;
	t*) upr=T ;; u*) upr=U ;; v*) upr=V ;; w*) upr=W ;;
	x*) upr=X ;; y*) upr=Y ;; z*) upr=Z ;; á*) upr=Á ;;
	é*) upr=É ;; í*) upr=Í ;; ó*) upr=Ó ;; ú*) upr=Ú ;;
	*) upr=${str%"${str#?}"} ;;
    esac
    printf -v $ref_c "%s" "$upr"  ## If you thought that quoting is not needed, What if character is a space?
}                                 ## We used "%s" instead of "%c" to add support for unicodes
_upper() { #@ DESCRIPTION: 
           #@ USAGE:
    set -- "${@:1:2}"
    __upper "$@"
}
upper() { #@ DESCRIPTION:
          #@ USAGE:
    set -- "${@:1:1}"
    local ___uppr=
    __upper ___uppr "$@"
    [ -n "$___uppr" ] && printf "%s\n" "$___uppr"
}

__to_upper() { #@ DESCRIPTION: 
               #@ USAGE:
    local ref_wrd=${1:?"${FUNCNAME[1]}: $_MISS_NMA_ERR_MSG"}
    local word=${2?"${FUNCNAME[1]}: $_MISS_ARG_ERR_MSG"}
    shift $#
    
    local __uppr=
    _upper __uppr "$word"
    printf -v $ref_word "%s%s" "$__uppr" "${word#?}"
}
_to_upper() {
    set -- "${@:1:2}"
    __to_upper "$@"
}
to_upper() { #@ DESCRIPTION: 
             #@ USAGE:
    set -- "${@:1:1}"
    local ___t_uppr=
    __to_upper ___t_uppr "$@"
    [ -n "$___t_uppr" ] && printf "%s\n" "$___t_uppr"
}

__loword() {
    :
}
_loword() {
    :
}
loword() {
    :
}

__upword() { #@ DESCRIPTION:
             #@ USAGE:
    local ref_word=${1:?"${FUNCNAME[1]}: $_MISS_NMA_ERR_MSG"}
    local word=${2?"${FUNCNAME[1]}: $_MISS_ARG_ERR_MSG"}
    shift $#

    local __uppr= upword=
    while [ -n "$word" ]; do  ## Loop until nothing is left in $word
	_upper __uppr "$word" ## Change to uppercase word's first char, storing it in _t_uppr
	upword+=$__uppr       ## Append _t_uppr current value in local upword
	word=${word#?}        ## Remove word's first char
    done
    printf -v $ref_word "%s" "$upword"
}
_upword() { #@ DESCRIPTION:
            #@ USAGE:
    set -- "${@:1:2}"    
    __upword "$@"
}
upword() { #@ DESCRIPTION:
           #@ USAGE:
    set -- "${@:1:1}"
    local ___upwrd=
    __upword ___upwrd "$@"
    [ -n "$___upwrd" ] && printf "%s\n" "$___upwrd"
}

__insert_string() { #@ DESCRIPTION:
                    #@ USAGE:
    local ref_insert_string=${1:?"${FUNCNAME[1]}: $_MISS_NMA_ERR_MSG"}
    local string=${2?"${FUNCNAME[1]}: $_MISS_ARG_ERR_MSG"}   ## String container
    local i_string=${3?"${FUNCNAME[1]}: $_MISS_ARG_ERR_MSG"} ## String to be inserted
    local -i i_pos=${4:-$_INSRT_STR_DFLT}                    ## Insert location
    shift $#

    local left=${string:0:i_pos - 1}                         ## Now using arithmetic expansion directly
    local right=${string:i_pos - 1}                          ## 
    printf -v $ref_insert_string "%s" "$left$i_string$right" ## Build new string on referenced variable
}
_insert_string() { #@ DESCRIPTION:
                   #@ USAGE:
    set -- "${@:1:4}"
    __insert_string "$@"
}
insert_string() { #@ DESCRIPTION:
                  #@ USAGE: 
    set -- "${@:1:3}"
    local ___insrt_strng=
    __insert_string ___insrt_strng "$@"
    [ -n "$___insrt_strng" ] && printf "%s\n" "$___insrt_strng"
}

__overlay() { #@ DESCRIPTION: 
              #@ USAGE:
    local ref_overlay=${1:?"${FUNCNAME[1]}: $_MISS_NMA_ERR_MSG"}
    local string=${2?"${FUNCNAME[1]}: $_MISS_ARG_ERR_MSG"}
    local sub=${3?"${FUNCNAME[1]}: $_MISS_ARG_ERR_MSG"}
    local -i start=${4:-$_OVRLY_STRT_DFLT}
    shift $#
    
    local left=${string:0:start - 1}
    local right=${string:start + ${#sub} - 1}
    printf -v $ref_overlay "%s" "$left$sub$right"
}
_overlay() {
    set -- "${@:1:4}"
    __overlay "$@"
}
overlay() { #@ DESCRIPTION:
            #@ USAGE:
    set -- "${@:1:3}"
    local ___overlay=
    __overlay ___overlay "$@"
    [ -n "$___overlay" ] && printf "%s\n" "$___overlay"
}

__ltrim() { #@ DESCRIPTION:
            #@ USAGE:
    local ref_trstr=${1:?"${FUNCNAME[1]}: $_MISS_ARG_ERR_MSG"}
    local trim_string=${2?"${FUNCNAME[1]}: $_MISS_ARG_ERR_MSG"}
    local to_trim=${3:-"$_TRM_STR_DFLT"}
    shift $#

    local trim=$trim_string
    trim_string=${trim%%[^"$to_trim"]*}
    printf -v $ref_trstr "%s" "${trim#"$trim_string"}"
}
_ltrim() { #@ DESCRIPTION:
           #@ USAGE:
    set -- "${@:1:3}"
    __ltrim "$@"
}
ltrim() { #@ DESCRIPTION:
          #@ USAGE:
    set -- "${@:1:2}"
    local ___ltrim=
    __ltrim ___ltrim "$@"
    [ -n "$___ltrim" ] && printf "%s\n" "$___ltrim"
}
__rtrim() { #@ DESCRIPTION:
            #@ USAGE:
    local ref_trstr=${1:?"${FUNCNAME[1]}: $_MISS_ARG_ERR_MSG"}
    local trim_string=${2?"${FUNCNAME[1]}: $_MISS_ARG_ERR_MSG"}
    local to_trim=${3:-"$_TRM_STR_DFLT"}
    shift $#

    local trim=$trim_string
    trim_string=${trim##*[^"$to_trim"]}
    printf -v $ref_trstr "%s" "${trim%"$trim_string"}"
}
_rtrim() { #@ DESCRIPTION:
           #@ USAGE:
    set -- "${@:1:3}"
    __rtrim "$@"
}
rtrim() { #@ DESCRIPTION:
          #@ USAGE:
    set -- "${@:1:2}"
    local ___rtrim=
    __rtrim ___rtrim "$@"
    [ -n "$___rtrim" ] && printf "%s\n" "$___rtrim"
}
__trim() { #@ DESCRIPTION:
           #@ USAGE:
    local ref_trstr=${1:?"${FUNCNAME[1]}: $_MISS_ARG_ERR_MSG"}
    local trim_string=${2?"${FUNCNAME[1]}: $_MISS_ARG_ERR_MSG"}
    local to_trim=${3:-"$_TRM_STR_DFLT"}
    shift $#

    local __trim=
    _ltrim __trim "$trim_string" "$to_trim"
    _rtrim __trim "$__trim" "$to_trim"
    printf -v $ref_trstr "%s" "$__trim"
}
trim() { #@ DESCRIPTION:
         #@ USAGE:
    set -- "${@:1:2}"
    local ___trim=
    __trim ___trim "$@"
    [ -n "$___trim" ] && printf "%s\n" "$___trim"
}

__index() { #@ DESCRIPTION: Store position (Use possition or index???) of $2 in $1 in $_INDEX
            #@ USAGE:
    local ref_index=${1:?"${FUNCNAME[1]}: $_MISS_NMA_ERR_MSG"}
    local string=${2:?"${FUNCNAME[1]}: Missing nonnull argument"} ## A random string
    local substr=${3:?"${FUNCNAME[1]}: Missing nonnull argument"} ## A substring of the previous one
    shift $# ## NOTE: Passing unset or null arguments makes no sense. No index could be retrieved
    
    local idx=       ## Random string after removing substring from its back
    local -i index=0 ## The index
    case $string in
	*"$substr"*)                     ## Is a substring? 
	    idx=${string%%"$substr"*}    ## Extract up to beginning of the matching part
	    index=$(( ${#idx} + 1 )) ;;  ## Starting pos is one more than length
	*)  return 1 ;;                  ## Handle any other cases
    esac
    printf -v $ref_index "%d" $index
}
_index() { #@ DESCRIPTION: 
           #@ USAGE:
    set -- "${@:1:3}"
    __index "$@"
}
index() { #@ DESCRIPTION:
          #@ USAGE:
    set -- "${@:1:2}"
    local -i ___indx=0
    if ! __index ___indx "$@"; then
	printf "%d\n" $___indx
	return 1
    fi
    printf "%d\n" $___indx
}

__month2num() { #@ DESCRIPTION:
                #@ USAGE:
    local ref_num=${1:?"${FUNCNAME[1]}: $_MISS_NMA_ERR_MSG"}
    local monthname=${2:?"${FUNCNAME[1]}: Missing nonnull argument"}
    shift $#
    
    local months=JAN.FEB.MAR.APR.MAY.JUN.JUL.AUG.SEP.OCT.NOV.DEC
    local __upwrd=
    local -i __indx=0
    _upword __upwrd "${monthname:0:3}"             ## Take first three letters of monthname to uppercase
    _index __indx "$months" "$__upwrd" || return 1 ## Is the monthame in months list?
    printf -v $ref_num "%d" $(( __indx / 4 + 1 ))  ## Turn first list's month first leter index to real index
}
_month2num() { #@ DESCRIPTION: 
               #@ USAGE:
    set -- "${@:1:2}"
    __month2num "$@"
}
month2num() {
    set -- "${@:1:1}"

    local -i ___mnth2nm=0
    __month2num ___mnth2nm "$@" && printf "%d\n" $___mnth2nm
}
