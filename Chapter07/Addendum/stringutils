#: Title       : Utils
#: Date        : 2016-06-21
#: Author      : "Kybernetes" <correodelkybernetes@gmail.com>
#: Version     : 1.0
#: Description : Bash function declarations file
#:             : Adds usefull string manipulation functions
#: Options     : N/A

## Global variables
declare -ri _INSERT_STRING_DFLT=2  ## Default insert string location
declare -ri _OVERLAY_START_DFLT=1  ## Default overlay string location

## Function declarations
__val2decint() { #@ DESCRIPTION: Primitive function. Turns valid decimal integer string $2 into decimal arithmetic
                 #@              evaluable by removing its leading zeros (sign skipped), and writes result in $1. 
                 #@              Otherwise it will be treated as octal inside an arithmetic evaluation.
                 #@ USAGE: __val2decint NAME '[ INT_STRING ]' (usable only inside intended wrappers)
    local ref_intstr=${1:?"${FUNCNAME[1]}: Missing name argument"}      ## ${FUNCNAME[1]} Expands to callling name
    local intstr=${2:?"${FUNCNAME[1]}: Missing valid integer argument"} ##
    shift $#
    ## NOTE: This "Primitive" is meant to be called only by a few "derived" wrappers, which assume that their header
    ##       will be handled by this primitive. This method provides heder reuse. Also Notice the reference to calling
    ##       function in above sustitutions.

    ## First keep hyphen character if present (negative integers);
    ## Then replace unsigned $integer w/its decimal representation
    printf -v $ref_intstr "%s" ${intstr%%[^-+]*}$(( 10#${intstr#[-+]} ))
}
_val2decint() { #@ DESCRIPTION: Derived. valid decimal integer string $2 into decimal arithmetic evaluable using
                #@              __val2decint, and writes result in $1. (Wrapper)
                #@ USAGE: _val2decint [ __val2decint args ]
    set -- "${@:1:2}" ## Keep only the first two positional pars. and rewrite "$@"
    __val2decint "$@"
}
val2decint() { #@ DESCRIPTION: Derived. Turns valid decimal integer string $2 into decimal arithmetic evaluable using
               #@              __val2decint, and writes result in STDOUT. (Wrapper)
               #@ USAGE: val2decint [ __val2decint args ]
    set -- "${@:1:1}" ## Keep only first positional par., and rewrite "$@"
    local ___vl2dcnt= ## Variable to be written by __val2decint
    __val2decint ___vl2dcnt "$@"
    printf "%d\n" $___vl2dcnt
}

__repeat() { #@ DESCRIPTION: Primitive. Repeat $2 string N times and write it to name $1
             #@ USAGE: __repeat NAME '[ STRING ]' [ NUMBER ]
    ## Function header
    local ref_rep=${1:?"${FUNCNAME[1]}: Missing name argument"}
    local repstr=${2?"${FUNCNAME[1]}: Missing argument"}
    local -i num=${3:-1}
    shift $#

    while (( ${#repstr} < $num && ${#repstr} > 0 )); do ## Loop until string exceeds desired length
	repstr+=$repstr$repstr                          ## 3 seems to be the optimum number
    done
    printf -v $ref_rep "%s" "${repstr:0:$num}"          ## Trim to desired length & write result
}
_repeat() { #@ DESCRIPTION: Derived
            #@ USAGE:
    set -- "${@:1:3}"
    __repeat "$@"
}
repeat() { #@ DESCRIPTION: Derived. Repeat a repstr N times
           #@ USAGE: repeat [ __repeat args ]
    set -- "${@:1:2}"                                   ## Keep only the first two arguments
    local ___rpt=                                       ## Variable to be written by _repeat
    _repeat ___rpt "$@"
    [ -n "$___rpt" ] && printf "%s\n" "$___rpt"
}

stdalert() { #@ DESCRIPTION: Prints in-box-alert-message
          #@ USAGE: alert '[ MESSAGE ]' [ BORDER ]
    local message=${1?"$FUNCNAME: Missing argument"}
    local border=${2:-#}
    shift $#
    
    local ___rpt=
    _repeat ___rpt "$border" $(( ${#message} + 6 ))
    printf '\a%s\n' "$___rpt" ## \a = BEL
    printf '%2.2s %s %2.2s\n' "$___rpt" "$message" "$___rpt"
    printf '%s\n' "$___rpt"
}

__revstr() { #@ DESCRIPTION: Functio core. Reverse $1 string order and store results
             #@ USAGE: revstr NAME [ STRING ]
    local ref_str=${1:?"${FUNCNAME[1]}: Missing argument as name"}
    local string=$2
    shift $#

    local temp= revstr=                 ## Now revstr is a local variable

    while [ -n "$string" ]; do          ## While string's size is not zero..
	temp=${string#?}                ## Get everything but first char on temp
	revstr=${string%"$temp"}$revstr ## Then get first char only, and place it at the beginning of global
	string=$temp                    ## Replace string with temp (remove its first char)
    done
    printf -v $ref_str "%s" "$revstr"   ## Print reversed string to referenced variable
}
_revstr() { #@ DESCRIPTION: 
            #@ USAGE:
    set -- "${@:1:2}"    
    __revstr "$@"
}
revstr() { #@ DESCRIPTION: Print reverse version of the string $1
           #@ USAGE: revstr [ STRING ]
    set -- "${@:1:1}"
    local ___rvstr=            ## Storage for refstr output
    _revstr ___rvstr "$@"      ## Revert string into above storage
    printf "%s\n" "$___rvstr"  ## Print it to STDOUT
}

__upper() { #@ DESCRIPTION: 
            #@ USAGE:
    local ref_c=${1:?"${FUNCNAME[1]}: Missing name argument"}
    local str=${2?"${FUNCNAME[1]}: Missing argument"}
    shift $#

    local upr=

    case $str in
	a*) upr=A ;; b*) upr=B ;; c*) upr=C ;; d*) upr=D ;;
	e*) upr=E ;; f*) upr=F ;; g*) upr=G ;; h*) upr=H ;;
	i*) upr=I ;; j*) upr=J ;; k*) upr=K ;; l*) upr=L ;;
	m*) upr=M ;; n*) upr=N ;; ñ*) upr=Ñ ;; o*) upr=O ;;
	p*) upr=P ;; q*) upr=Q ;; r*) upr=R ;; s*) upr=S ;;
	t*) upr=T ;; u*) upr=U ;; v*) upr=V ;; w*) upr=W ;;
	x*) upr=X ;; y*) upr=Y ;; z*) upr=Z ;; á*) upr=Á ;;
	é*) upr=É ;; í*) upr=Í ;; ó*) upr=Ó ;; ú*) upr=Ú ;;
	*) upr=${str%"${str#?}"} ;;
    esac
    printf -v $ref_c "%s" "$upr"  ## If you thought that quoting is not needed, What if character is a space?
}                                 ## We used "%s" instead of "%c" to add support for unicodes
_upper() { #@ DESCRIPTION: 
           #@ USAGE:
    set -- "${@:1:2}"
    __upper "$@"
}
upper() { #@ DESCRIPTION:
          #@ USAGE:
    set -- "${@:1:1}"
    local ___uppr=
    __upper ___uppr "$@"
    [ -n "$___uppr" ] && printf "%s\n" $___uppr
}

__to_upper() { #@ DESCRIPTION: 
               #@ USAGE:
    local ref_wrd=${1:?"${FUNCNAME[1]}: Missing name argument"}
    local word=${2?"${FUNCNAME[1]}: Missing argument"}
    shift $#
    
    local __uppr=
    _upper __uppr "$word"
    printf -v $ref_word "%s%s" $__uppr "${word#?}"
}
_to_upper() {
    set -- "${@:1:2}"
    __to_upper "$@"
}
to_upper() { #@ DESCRIPTION: 
             #@ USAGE:
    set -- "${@:1:1}"
    local ___t_uppr=
    __to_upper ___t_uppr "$@"
    [ -n "$___t_uppr" ] && printf "%s\n" "$___t_uppr"
}

__upword() { #@ DESCRIPTION:
             #@ USAGE:
    local ref_word=${1:?"${FUNCNAME[1]}: Missing name argument"}
    local word=${2?"${FUNCNAME[1]}: Missing argument"}
    shift $#

    local __uppr= upword=
    while [ -n "$word" ]; do  ## Loop until nothing is left in $word
	_upper __uppr "$word" ## Change to uppercase word's first char, storing it in _t_uppr
	upword+=$__uppr       ## Append _t_uppr current value in local upword
	word=${word#?}        ## Remove word's first char
    done
    printf -v $ref_word "%s" "$upword"
}
_upword() { #@ DESCRIPTION:
            #@ USAGE:
    set -- "${@:1:2}"    
    __upword "$@"
}
upword() { #@ DESCRIPTION:
           #@ USAGE:
    set -- "${@:1:1}"
    local ___upwrd=
    __upword ___upwrd "$@"
    [ -n "$___upwrd" ] && printf "%s\n" "$___upwrd"
}

__insert_string() { #@ DESCRIPTION:
                    #@ USAGE:
    local ref_insert_string=${1:?"${FUNCNAME[1]}: Missing name argument"}
    local string=${2?"${FUNCNAME[1]}: Missing argument"}   ## String container
    local i_string=${3?"${FUNCNAME[1]}: Missing argument"} ## String to be inserted
    local -i i_pos=${4:-$_INSERT_STRING_DFLT}              ## Insert location
    shift $#

    local left=${string:0:i_pos - 1}                         ## Now using arithmetic expansion directly
    local right=${string:i_pos - 1}                          ## 
    printf -v $ref_insert_string "%s" "$left$i_string$right" ## Build new string on referenced variable
}
_insert_string() { #@ DESCRIPTION:
                   #@ USAGE:
    set -- "${@:1:4}"
    __insert_string "$@"
}
insert_string() { #@ DESCRIPTION:
                  #@ USAGE: 
    set -- "${@:1:3}"
    local ___insrt_strng=
    __insert_string ___insrt_strng "$@"
    [ -n "$___insrt_strng" ] && printf "%s\n" "$___insrt_strng"
}

__overlay() { #@ DESCRIPTION: 
             #@ USAGE:
    local ref_overlay=${1:?"${FUNCNAME[1]}: Missing name argument"}
    local string=${2?"${FUNCNAME[1]}: Missing argumeng"}
    local sub=${3?"${FUNCNAME[1]}: Missing argumeng"}
    local -i start=${4:-$_OVERLAY_START_DFLT}
    shift $#
    
    local left=${string:0:start - 1}
    local right=${string:start + ${#sub} - 1}
    printf -v $ref_overlay "%s" "$left$sub$right"
}
_overlay() {
    set -- "${@:1:4}"
    __overlay "$@"
}
overlay() { #@ DESCRIPTION:
            #@ USAGE:
    set -- "${@:1:3}"
    local ___overlay=
    __overlay ___overlay "$@"
    [ -n "$___overlay" ] && printf "%s\n" "$___overlay"
}

__trim() { #@ DESCRIPTION: 
          #@ USAGE:
    local ref_trstr=${1:?"$FUNCNAME: Missing argument"}
    local trim_string=$2  ## Input string
    local to_trim=${3:- } ## Part to be removed (default to space)
    shift $#

    local trim=$trim_string
    ## Remove all from beginning, up to the first character different to trim, and store it in trim_string
    trim_string=${trim##*[^"$to_trim"]} ## Not just single chars but entire strings are supported by negation
    ## Keep what we didn't remove before in trim
    trim=${trim%"$trim_string"}
    ## Remove all from back, up to the first character different to trim
    trim_string=${trim%%[^"$to_trim"]*} ## Quote to preven reinterpretation of specials
    ## Keep what we didn't remove before in trim
    printf -v $ref_trstr "%s" "${trim#"$trim_string"}"
}
__trim() {
    set -- "${@:1:3}"
    __trim "$@"
}
trim() { #@ DESCRIPCION:
         #@ USAGE:
    set -- "${@:1:2}"
    local ___trm=
    __trim ___trm "$@"
    [ -n "$___trm" ] && printf "%s\n" "$___trm"
}

__index() { #@ DESCRIPTION: Store position of $2 in $1 in $_INDEX
            #@ USAGE:
    local ref_index=${1:?"${FUNCNAME[1]}: Missing name argument"}
    local string=${2:?"${FUNCNAME[1]}: Missing nonnull argument"} ## A random string
    local substr=${3:?"${FUNCNAME[1]}: Missing nonnull argument"} ## A substring of the previous one
    shift $# ## NOTE: Passing unset or null arguments makes no sense. No index could be retrieved
    
    local idx=       ## Random string after removing substring from its back
    local -i index=0 ## The index
    case $string in
	*"$substr"*)                     ## Is a substring? 
	    idx=${string%%"$substr"*}    ## Extract up to beginning of the matching part
	    index=$(( ${#idx} + 1 )) ;;  ## Starting pos is one more than length
	*)  return 1 ;;                  ## Handle any other cases
    esac
    printf -v $ref_index "%d" $index
}
_index() { #@ DESCRIPTION: 
           #@ USAGE:
    set -- "${@:1:3}"
    __index "$@"
}
index() { #@ DESCRIPTION:
          #@ USAGE:
    set -- "${@:1:2}"
    local -i ___indx=0
    if ! __index ___indx "$@"; then
	printf "%d\n" $___indx
	return 1
    fi
    printf "%d\n" $___indx
}

__month2num() { #@ DESCRIPTION:
                #@ USAGE:
    local ref_num=${1:?"${FUNCNAME[1]}: Missing name argument"}
    local monthname=${2:?"${FUNCNAME[1]}: Missing nonnull argument"}
    shift $#
    
    local months=JAN.FEB.MAR.APR.MAY.JUN.JUL.AUG.SEP.OCT.NOV.DEC
    local __upwrd=
    local -i __indx=0
    _upword __upwrd "${monthname:0:3}"             ## Take first three letters of monthname to uppercase
    _index __indx "$months" "$__upwrd" || return 1 ## Is the monthame in months list?
    printf -v $ref_num "%d" $(( __indx / 4 + 1 ))  ## Turn first list's month first leter index to real index
}
_month2num() { #@ DESCRIPTION: 
               #@ USAGE:
    set -- "${@:1:2}"
    __month2num "$@"
}
month2num() {
    set -- "${@:1:1}"

    local -i ___mnth2nm=0
    __month2num ___mnth2nm "$@" && printf "%d\n" $___mnth2nm
}
